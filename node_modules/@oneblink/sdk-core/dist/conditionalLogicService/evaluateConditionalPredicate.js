"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const typeCastService_1 = require("../typeCastService");
const evaluateConditionalOptionsPredicate_1 = __importDefault(require("./evaluateConditionalOptionsPredicate"));
const fnMap = {
    '>': (lhs, rhs) => lhs > rhs,
    '>=': (lhs, rhs) => lhs >= rhs,
    '===': (lhs, rhs) => lhs === rhs,
    '!==': (lhs, rhs) => lhs !== rhs,
    '<=': (lhs, rhs) => lhs <= rhs,
    '<': (lhs, rhs) => lhs < rhs,
};
function getElementAndValue(formElementsCtrl, elementId) {
    const formElement = formElementsCtrl.flattenedElements.find((formElement) => formElement.id === elementId);
    if (formElement) {
        const formElementWithName = typeCastService_1.formElements.toNamedElement(formElement);
        if (formElementWithName) {
            return {
                formElementWithName,
                value: formElementsCtrl.model[formElementWithName.name],
            };
        }
    }
    else if (formElementsCtrl.parentFormElementsCtrl) {
        return getElementAndValue(formElementsCtrl.parentFormElementsCtrl, elementId);
    }
    return {};
}
function evaluateConditionalPredicate({ predicate, formElementsCtrl, }) {
    const { formElementWithName: predicateElement, value: predicateValue } = getElementAndValue(formElementsCtrl, predicate.elementId);
    if (!predicateElement) {
        return;
    }
    switch (predicate.type) {
        case 'VALUE': {
            return !predicate.hasValue === !predicateValue
                ? predicateElement
                : undefined;
        }
        case 'NUMERIC': {
            // if the operator fn doesn't exist, hide the control
            const operatorFn = fnMap[predicate.operator];
            if (!operatorFn)
                return undefined;
            const lhs = Number.parseFloat(predicateValue);
            // if left is not a number, hide the control
            if (isNaN(lhs))
                return undefined;
            let rhsValue = NaN;
            switch (predicate.compareWith) {
                case 'ELEMENT': {
                    const { value: comparisonValue } = getElementAndValue(formElementsCtrl, predicate.value);
                    rhsValue =
                        comparisonValue === 'string'
                            ? Number.parseFloat(comparisonValue)
                            : comparisonValue;
                    break;
                }
                case 'VALUE':
                default: {
                    rhsValue = predicate.value;
                    break;
                }
            }
            const rhs = typeof rhsValue === 'string' ? Number.parseFloat(rhsValue) : rhsValue;
            // if right is not a number, hide the control
            if (isNaN(rhs))
                return undefined;
            return operatorFn(lhs, rhs) ? predicateElement : undefined;
        }
        case 'BETWEEN': {
            const value = Number.parseFloat(predicateValue);
            if (Number.isNaN(value)) {
                return undefined;
            }
            return value >= predicate.min && value <= predicate.max
                ? predicateElement
                : undefined;
        }
        case 'OPTIONS':
        default: {
            const optionsPredicateElement = __1.typeCastService.formElements.toOptionsElement(predicateElement);
            if (!optionsPredicateElement) {
                return undefined;
            }
            // If the predicate element does not have any options to evaluate,
            // we will show the element.
            // Unless the predicate element has dynamic options and
            // options have not been fetched yet.
            if (!Array.isArray(optionsPredicateElement.options)) {
                return optionsPredicateElement.optionsType !== 'DYNAMIC'
                    ? predicateElement
                    : undefined;
            }
            else {
                return (0, evaluateConditionalOptionsPredicate_1.default)({
                    predicate,
                    predicateValue,
                    predicateElement: optionsPredicateElement,
                })
                    ? predicateElement
                    : undefined;
            }
        }
    }
}
exports.default = evaluateConditionalPredicate;
//# sourceMappingURL=evaluateConditionalPredicate.js.map