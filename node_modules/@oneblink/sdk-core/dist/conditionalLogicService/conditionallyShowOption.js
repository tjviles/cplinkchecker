"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const evaluateConditionalOptionsPredicate_1 = __importDefault(require("./evaluateConditionalOptionsPredicate"));
const __1 = require("..");
const conditionallyShowElement_1 = __importDefault(require("./conditionallyShowElement"));
const handleAttributePredicate = (predicate, model, predicateElement) => {
    const values = model[predicateElement.name];
    if (!values)
        return true;
    if (Array.isArray(values) &&
        (!values.length ||
            !values.filter((value) => typeof value !== 'undefined').length)) {
        return true;
    }
    return (0, evaluateConditionalOptionsPredicate_1.default)({
        predicate: {
            type: 'OPTIONS',
            elementId: predicate.elementId,
            optionIds: predicate.optionIds,
        },
        predicateValue: values,
        predicateElement,
    });
};
const conditionallyShowOptionByPredicate = (formElementsCtrl, predicate, elementsEvaluated) => {
    // Validate the predicate data, if it is invalid,
    // we will always show the field
    if (!predicate ||
        !predicate.elementId ||
        !predicate.optionIds ||
        !predicate.optionIds.length) {
        return true;
    }
    const predicateElement = formElementsCtrl.flattenedElements.find((element) => {
        return element.id === predicate.elementId;
    });
    // If we cant find the element used for the predicate,
    // we can check to see if the element being evaluated
    // is in a repeatable set and the predicate element is
    // in a parent list of elements.
    if (!predicateElement) {
        if (formElementsCtrl.parentFormElementsCtrl) {
            return conditionallyShowOptionByPredicate(formElementsCtrl.parentFormElementsCtrl, predicate, elementsEvaluated);
        }
        else {
            return false;
        }
    }
    const optionsPredicateElement = __1.typeCastService.formElements.toOptionsElement(predicateElement);
    if (!optionsPredicateElement) {
        return false;
    }
    // If the predicate element does not have any options to evaluate,
    // we will show the element.
    // Unless the predicate element has dynamic options and
    // options have not been fetched yet.
    if (!Array.isArray(optionsPredicateElement.options)) {
        return optionsPredicateElement.optionsType !== 'DYNAMIC';
    }
    const everyOptionIsShowing = predicate.optionIds.every((id) => {
        var _a;
        const predicateOption = (_a = optionsPredicateElement.options) === null || _a === void 0 ? void 0 : _a.find((o) => o.id === id);
        if (!predicateOption)
            return false;
        return conditionallyShowOption({ model: formElementsCtrl.model, flattenedElements: [] }, optionsPredicateElement, predicateOption, elementsEvaluated);
    });
    if (!everyOptionIsShowing) {
        return false;
    }
    // Check to see if the model has one of the valid values to show the element
    return handleAttributePredicate(predicate, formElementsCtrl.model, optionsPredicateElement);
};
const isAttributeFilterValid = (formElementsCtrl, predicate, elementsEvaluated) => {
    const predicateElement = formElementsCtrl.flattenedElements.find((element) => {
        return element.id === predicate.elementId;
    });
    // If we cant find the element used for the predicate,
    // we can check to see if the element being evaluated
    // is in a repeatable set and the predicate element is
    // in a parent list of elements.
    if (!predicateElement) {
        if (formElementsCtrl.parentFormElementsCtrl) {
            return isAttributeFilterValid(formElementsCtrl.parentFormElementsCtrl, predicate, elementsEvaluated);
        }
        else {
            return false;
        }
    }
    // now we have the model and predicate element, verify that the predicate element
    // is not hidden
    if (
    // Will never be a page, just making typescript happy :)
    predicateElement.type === 'page' ||
        predicateElement.type === 'section' ||
        !(0, conditionallyShowElement_1.default)(formElementsCtrl, predicateElement, [])) {
        return false;
    }
    // verify that at least one option is selected
    const values = formElementsCtrl.model[predicateElement.name];
    if (!values)
        return false;
    // if the model value is an array, verify that it has a selection
    if (Array.isArray(values) &&
        (!values.length ||
            !values.filter((value) => typeof value !== 'undefined').length)) {
        return false;
    }
    return true;
};
function conditionallyShowOption(formElementsCtrl, elementToEvaluate, optionToEvaluate, optionsEvaluated) {
    // If the element does not have the `conditionallyShow` flag set,
    // we can always show the element.
    if (!elementToEvaluate.conditionallyShowOptions ||
        !optionToEvaluate ||
        !optionToEvaluate.attributes ||
        !Array.isArray(optionToEvaluate.attributes) ||
        !optionToEvaluate.attributes.length) {
        return true;
    }
    // Check to see if this element has already been used to evaluate
    // if the element should be shown based on parent element conditional logic
    if (optionsEvaluated.some((optionId) => optionId === optionToEvaluate.id)) {
        throw new Error('Your conditional logic has caused an infinite loop. Check the following Fields to ensure element A does not rely on element B if element B also relies on element A.');
    }
    else {
        optionsEvaluated.push(optionToEvaluate.id);
    }
    const validPredicates = (optionToEvaluate.attributes || []).filter((predicate) => {
        return isAttributeFilterValid(formElementsCtrl, predicate, optionsEvaluated);
    });
    if (!validPredicates.length)
        return true;
    return validPredicates.some((predicate) => conditionallyShowOptionByPredicate(formElementsCtrl, predicate, optionsEvaluated));
}
exports.default = conditionallyShowOption;
//# sourceMappingURL=conditionallyShowOption.js.map