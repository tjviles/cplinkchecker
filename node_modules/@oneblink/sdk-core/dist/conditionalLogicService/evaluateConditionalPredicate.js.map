{"version":3,"file":"evaluateConditionalPredicate.js","sourceRoot":"","sources":["../../src/conditionalLogicService/evaluateConditionalPredicate.ts"],"names":[],"mappings":"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","sourcesContent":["import { FormTypes, ConditionTypes } from '@oneblink/types'\nimport { typeCastService } from '..'\nimport { formElements } from '../typeCastService'\nimport { FormElementsCtrl } from '../types'\nimport evaluateConditionalOptionsPredicate from './evaluateConditionalOptionsPredicate'\n\nconst fnMap = {\n  '>': (lhs: number, rhs: number) => lhs > rhs,\n  '>=': (lhs: number, rhs: number) => lhs >= rhs,\n  '===': (lhs: number, rhs: number) => lhs === rhs,\n  '!==': (lhs: number, rhs: number) => lhs !== rhs,\n  '<=': (lhs: number, rhs: number) => lhs <= rhs,\n  '<': (lhs: number, rhs: number) => lhs < rhs,\n}\n\nfunction getElementAndValue(\n  formElementsCtrl: FormElementsCtrl,\n  elementId: string,\n): { formElementWithName?: FormTypes.FormElementWithName; value?: unknown } {\n  const formElement = formElementsCtrl.flattenedElements.find(\n    (formElement) => formElement.id === elementId,\n  )\n  if (formElement) {\n    const formElementWithName = formElements.toNamedElement(formElement)\n    if (formElementWithName) {\n      return {\n        formElementWithName,\n        value: formElementsCtrl.model[formElementWithName.name],\n      }\n    }\n  } else if (formElementsCtrl.parentFormElementsCtrl) {\n    return getElementAndValue(\n      formElementsCtrl.parentFormElementsCtrl,\n      elementId,\n    )\n  }\n  return {}\n}\n\nexport default function evaluateConditionalPredicate({\n  predicate,\n  formElementsCtrl,\n}: {\n  predicate: ConditionTypes.ConditionalPredicate\n  formElementsCtrl: FormElementsCtrl\n}): FormTypes.FormElementWithName | undefined {\n  const { formElementWithName: predicateElement, value: predicateValue } =\n    getElementAndValue(formElementsCtrl, predicate.elementId)\n  if (!predicateElement) {\n    return\n  }\n  switch (predicate.type) {\n    case 'VALUE': {\n      return !predicate.hasValue === !predicateValue\n        ? predicateElement\n        : undefined\n    }\n    case 'NUMERIC': {\n      // if the operator fn doesn't exist, hide the control\n      const operatorFn = fnMap[predicate.operator]\n      if (!operatorFn) return undefined\n\n      const lhs = Number.parseFloat(predicateValue as string)\n      // if left is not a number, hide the control\n      if (isNaN(lhs)) return undefined\n\n      let rhsValue = NaN\n      switch (predicate.compareWith) {\n        case 'ELEMENT': {\n          const { value: comparisonValue } = getElementAndValue(\n            formElementsCtrl,\n            predicate.value,\n          )\n          rhsValue =\n            comparisonValue === 'string'\n              ? Number.parseFloat(comparisonValue)\n              : (comparisonValue as number)\n          break\n        }\n        case 'VALUE':\n        default: {\n          rhsValue = predicate.value\n          break\n        }\n      }\n\n      const rhs =\n        typeof rhsValue === 'string' ? Number.parseFloat(rhsValue) : rhsValue\n\n      // if right is not a number, hide the control\n      if (isNaN(rhs)) return undefined\n\n      return operatorFn(lhs, rhs) ? predicateElement : undefined\n    }\n    case 'BETWEEN': {\n      const value = Number.parseFloat(predicateValue as string)\n      if (Number.isNaN(value)) {\n        return undefined\n      }\n\n      return value >= predicate.min && value <= predicate.max\n        ? predicateElement\n        : undefined\n    }\n    case 'OPTIONS':\n    default: {\n      const optionsPredicateElement =\n        typeCastService.formElements.toOptionsElement(predicateElement)\n      if (!optionsPredicateElement) {\n        return undefined\n      }\n\n      // If the predicate element does not have any options to evaluate,\n      // we will show the element.\n      // Unless the predicate element has dynamic options and\n      // options have not been fetched yet.\n      if (!Array.isArray(optionsPredicateElement.options)) {\n        return optionsPredicateElement.optionsType !== 'DYNAMIC'\n          ? predicateElement\n          : undefined\n      } else {\n        return evaluateConditionalOptionsPredicate({\n          predicate,\n          predicateValue,\n          predicateElement: optionsPredicateElement,\n        })\n          ? predicateElement\n          : undefined\n      }\n    }\n  }\n}\n"]}