"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenFormElements = exports.parseFormElementOptionsSet = exports.findFormElement = exports.forEachFormElementWithOptions = exports.forEachFormElement = void 0;
const _1 = require(".");
/**
 * Iterate over all form elements, also iterating over nested form element (e.g.
 * page elements).
 *
 * #### Example
 *
 * ```js
 * formElementsService.forEachFormElement(form.elements, (formElement) => {
 *   // do something with formElement
 * })
 * ```
 *
 * @param elements The form elements to iterate over
 * @param forEach Function to execute on each form element
 */
function forEachFormElement(elements, forEach) {
    findFormElement(elements, (formElement, parentElements) => {
        forEach(formElement, parentElements);
        return false;
    });
}
exports.forEachFormElement = forEachFormElement;
/**
 * Iterate over all form elements that have options (e.g. `'select'` type
 * elements), also iterating over nested form element (e.g. page elements).
 *
 * #### Example
 *
 * ```js
 * formElementsService.forEachFormElementWithOptions(
 *   form.elements,
 *   (formElementWithOptions) => {
 *     // do something with formElementWithOptions
 *   },
 * )
 * ```
 *
 * @param elements The form elements to iterate over
 * @param forEach Function to execute on each form element with options
 */
function forEachFormElementWithOptions(elements, forEach) {
    findFormElement(elements, (formElement, parentElements) => {
        const optionsFormElement = _1.typeCastService.formElements.toOptionsElement(formElement);
        if (optionsFormElement) {
            forEach(optionsFormElement, parentElements);
        }
        return false;
    });
}
exports.forEachFormElementWithOptions = forEachFormElementWithOptions;
/**
 * Iterate over all form elements and return an element that matches a
 * predicate, also iterating over nested form element (e.g. page elements). Will
 * return `undefined` if no matching element is found.
 *
 * #### Example
 *
 * ```js
 * const formElement = formElementsService.findFormElement(
 *   form.elements,
 *   (formElement) => {
 *     return formElement.id === '123-abc'
 *   },
 * )
 * ```
 *
 * @param elements The form elements to iterate over
 * @param predicate Predicate function to execute on each form element
 * @param parentElements
 * @returns
 */
function findFormElement(elements, predicate, parentElements = []) {
    for (const element of elements) {
        if (predicate(element, parentElements)) {
            return element;
        }
        if ((element.type === 'repeatableSet' ||
            element.type === 'page' ||
            element.type === 'form' ||
            element.type === 'infoPage' ||
            element.type === 'section') &&
            Array.isArray(element.elements)) {
            const nestedElement = findFormElement(element.elements, predicate, [
                ...parentElements,
                element,
            ]);
            if (nestedElement) {
                return nestedElement;
            }
        }
    }
}
exports.findFormElement = findFormElement;
/**
 * Parse unknown data as valid options for a forms element. This will always
 * return an Array of valid options.
 *
 * #### Example
 *
 * ```js
 * const options = formElementsService.parseFormElementOptionsSet(data)
 * // "options" are valid for a form element
 * ```
 *
 * @param data
 * @returns
 */
function parseFormElementOptionsSet(data) {
    if (!Array.isArray(data)) {
        return [];
    }
    return data.reduce((options, record, index) => {
        if (typeof record === 'string') {
            options.push({
                id: index.toString(),
                value: record,
                label: record,
            });
        }
        else if (typeof record === 'object') {
            const option = record;
            const value = typeof option.value === 'string' && option.value
                ? option.value
                : index.toString();
            const id = typeof option.id === 'string' && option.id ? option.id : value;
            const label = typeof option.label === 'string' && option.label
                ? option.label
                : value;
            const colour = typeof option.colour === 'string' && option.colour
                ? option.colour
                : undefined;
            options.push({
                ...option,
                id,
                value,
                label,
                colour,
            });
        }
        return options;
    }, []);
}
exports.parseFormElementOptionsSet = parseFormElementOptionsSet;
/**
 * Takes the nested definition structure and returns all form elements as 1d array.
 *
 * #### Example
 *
 * ```js
 * const flattenedElements = formElementsService.flattenFormElements(
 *   form.elements,
 * )
 * ```
 *
 * @param elements
 * @returns
 */
function flattenFormElements(elements) {
    return elements.reduce((flattenedElements, element) => {
        flattenedElements.push(element);
        switch (element.type) {
            case 'section':
            case 'page': {
                flattenedElements.push(...flattenFormElements(element.elements));
            }
        }
        return flattenedElements;
    }, []);
}
exports.flattenFormElements = flattenFormElements;
//# sourceMappingURL=formElementsService.js.map