"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptUserToken = exports.encryptUserToken = void 0;
const crypto_1 = __importDefault(require("crypto"));
const ALGORITHM = 'aes-256-cbc';
const IV_LENGTH = 16; // For AES, this is always 16
// Encryption key for this algorithm must be 256 bits (32 characters)
const generateEncryptionKey = (secret) => crypto_1.default.createHash('md5').update(secret).digest('hex');
function encryptUserToken({ username, secret, }) {
    const encryptionKey = generateEncryptionKey(secret);
    const iv = crypto_1.default.randomBytes(IV_LENGTH);
    const cipher = crypto_1.default.createCipheriv(ALGORITHM, Buffer.from(encryptionKey), iv);
    let encrypted = cipher.update(Buffer.from(username, 'utf8'));
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return Buffer.concat([iv, encrypted]).toString('base64');
}
exports.encryptUserToken = encryptUserToken;
function decryptUserToken({ userToken, secret, }) {
    const encryptionKey = generateEncryptionKey(secret);
    const data = Buffer.from(userToken, 'base64');
    const iv = Buffer.alloc(IV_LENGTH);
    const encryptedText = Buffer.alloc(data.length - iv.length);
    data.copy(iv, 0, 0, iv.length);
    data.copy(encryptedText, 0, iv.length);
    const decipher = crypto_1.default.createDecipheriv(ALGORITHM, Buffer.from(encryptionKey), iv);
    let decrypted = decipher.update(encryptedText);
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    return decrypted.toString();
}
exports.decryptUserToken = decryptUserToken;
//# sourceMappingURL=user-token-helpers.js.map