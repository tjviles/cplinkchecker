"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.customCssClasses = exports.canToggleAll = exports.regexSchemas = exports.storageType = exports.conditionallyShowSchemas = exports.lookupSchemas = exports.conditionallyShowPredicates = exports.ConditionalPredicatesItemSchema = exports.optionsSchemas = exports.defaultValueOptionsMultiple = exports.defaultValueOptionsSingle = exports.buttons = exports.placeholderValue = exports.readOnly = exports.requiredSchemas = exports.hint = exports.baseSchemas = exports.meta = exports.label = exports.name = exports.id = void 0;
const joi_1 = __importDefault(require("joi"));
const common_1 = require("./common");
exports.id = joi_1.default.string().guid().required();
exports.name = joi_1.default.string().required().trim();
exports.label = joi_1.default.string().required();
exports.meta = joi_1.default.string().custom((value) => {
    JSON.parse(value);
    return value;
});
/**
 * This property is spread onto every element schema. Any new properties that
 * will be on ALL elements can be safely added here.
 */
exports.baseSchemas = {
    id: exports.id,
    meta: exports.meta,
};
exports.hint = joi_1.default.string();
const required = joi_1.default.bool().default(false);
const requiredMessage = joi_1.default.string().trim();
exports.requiredSchemas = {
    required,
    requiredMessage,
};
exports.readOnly = joi_1.default.bool().default(false);
exports.placeholderValue = joi_1.default.string();
exports.buttons = joi_1.default.boolean().default(false);
const optionsType = joi_1.default.string()
    .default(common_1.CUSTOM_OPTION_TYPE)
    .when('type', {
    is: 'autocomplete',
    then: joi_1.default.valid(...common_1.optionTypes, common_1.SEARCH_OPTION_TYPE),
    otherwise: joi_1.default.valid(...common_1.optionTypes),
});
const dynamicOptionSetId = joi_1.default.when('optionsType', {
    is: common_1.DYNAMIC_OPTION_TYPE,
    then: joi_1.default.number().required(),
    otherwise: joi_1.default.any().strip(),
});
const options = joi_1.default.when('optionsType', {
    is: common_1.CUSTOM_OPTION_TYPE,
    then: joi_1.default.array()
        .unique('id')
        .items(joi_1.default.object().keys({
        id: joi_1.default.string().guid().required(),
        value: joi_1.default.string().required().trim(),
        label: joi_1.default.string().required(),
        colour: joi_1.default.string()
            .allow(null, '')
            .regex(/^#[A-Fa-f0-9]{3}([A-Fa-f0-9]{3})?$/),
        attributes: joi_1.default.array().items(joi_1.default.object().keys({
            optionIds: joi_1.default.array().required().items(joi_1.default.string()),
            elementId: joi_1.default.string().guid().required(),
        })),
    }))
        .required(),
    otherwise: joi_1.default.any().strip(),
});
const attributesMapping = joi_1.default.when('optionsType', {
    is: common_1.DYNAMIC_OPTION_TYPE,
    then: joi_1.default.array().items(joi_1.default.object().keys({
        elementId: joi_1.default.string().guid().required(),
        attribute: joi_1.default.string().required(),
    })),
    otherwise: joi_1.default.any().strip(),
});
const conditionallyShowOptions = joi_1.default.when('type', {
    is: joi_1.default.valid('checkboxes', 'radio', 'select', 'autocomplete', 'compliance'),
    then: joi_1.default.boolean().default(false),
    otherwise: joi_1.default.any().strip(),
});
const conditionallyShowOptionsElementIds = joi_1.default.when('optionsType', {
    is: common_1.CUSTOM_OPTION_TYPE,
    then: joi_1.default.array().items(joi_1.default.string().guid().required()),
    otherwise: joi_1.default.any().strip(),
});
const freshdeskFieldName = joi_1.default.when('optionsType', {
    is: common_1.FRESHDESK_FIELD_OPTION_TYPE,
    then: joi_1.default.string().required(),
    otherwise: joi_1.default.any().strip(),
});
exports.defaultValueOptionsSingle = joi_1.default.when('optionsType', {
    is: joi_1.default.invalid(common_1.DYNAMIC_OPTION_TYPE, common_1.FRESHDESK_FIELD_OPTION_TYPE),
    then: joi_1.default.string().guid(),
    otherwise: joi_1.default.string(),
});
exports.defaultValueOptionsMultiple = joi_1.default.when('optionsType', {
    is: joi_1.default.invalid(common_1.DYNAMIC_OPTION_TYPE, common_1.FRESHDESK_FIELD_OPTION_TYPE),
    then: joi_1.default.array().items(joi_1.default.string().guid()),
    otherwise: joi_1.default.array().items(joi_1.default.string()),
});
exports.optionsSchemas = {
    optionsType,
    dynamicOptionSetId,
    options,
    attributesMapping,
    conditionallyShowOptions,
    conditionallyShowOptionsElementIds,
    freshdeskFieldName,
};
const conditionallyShow = joi_1.default.bool().default(false);
const requiresAllConditionallyShowPredicates = joi_1.default.when('conditionallyShow', {
    is: true,
    then: joi_1.default.bool().default(false),
    otherwise: joi_1.default.any().strip(),
});
exports.ConditionalPredicatesItemSchema = joi_1.default.object().keys({
    elementId: joi_1.default.string().guid().required(),
    type: joi_1.default.string()
        .default('OPTIONS')
        .valid('OPTIONS', 'NUMERIC', 'VALUE', 'BETWEEN'),
    optionIds: joi_1.default.when('type', {
        is: joi_1.default.valid('OPTIONS'),
        then: joi_1.default.array().min(1).items(joi_1.default.string()).required(),
        otherwise: joi_1.default.any().strip(),
    }),
    operator: joi_1.default.when('type', {
        is: joi_1.default.valid('NUMERIC'),
        then: joi_1.default.string().valid('>', '>=', '===', '!==', '<=', '<').required(),
        otherwise: joi_1.default.any().strip(),
    }),
    compareWith: joi_1.default.when('type', {
        is: joi_1.default.valid('NUMERIC'),
        then: joi_1.default.valid('ELEMENT', 'VALUE'),
        otherwise: joi_1.default.any().strip(),
    }),
    value: joi_1.default.when('type', {
        is: joi_1.default.valid('NUMERIC'),
        then: joi_1.default.when('compareWith', {
            is: joi_1.default.valid('ELEMENT').required(),
            then: joi_1.default.string().guid().required(),
            otherwise: joi_1.default.number().required(),
        }),
        otherwise: joi_1.default.any().strip(),
    }),
    hasValue: joi_1.default.when('type', {
        is: joi_1.default.valid('VALUE'),
        then: joi_1.default.boolean().required(),
        otherwise: joi_1.default.any().strip(),
    }),
    min: joi_1.default.when('type', {
        is: joi_1.default.valid('BETWEEN'),
        then: joi_1.default.number().required(),
        otherwise: joi_1.default.any().strip(),
    }),
    max: joi_1.default.when('type', {
        is: joi_1.default.valid('BETWEEN'),
        then: joi_1.default.number()
            .min(joi_1.default.ref('min', { render: true }))
            .required(),
        otherwise: joi_1.default.any().strip(),
    }),
});
exports.conditionallyShowPredicates = joi_1.default.when('conditionallyShow', {
    is: true,
    then: joi_1.default.array()
        .unique('elementId')
        .min(1)
        .items(exports.ConditionalPredicatesItemSchema)
        .required(),
    otherwise: joi_1.default.any().strip(),
});
// Data lookup configuration
const isDataLookup = joi_1.default.boolean().default(false);
const dataLookupId = joi_1.default.when('isDataLookup', {
    is: true,
    then: joi_1.default.number().required(),
    otherwise: joi_1.default.any().strip(),
});
// Element lookup configuration
const isElementLookup = joi_1.default.boolean().default(false);
const elementLookupId = joi_1.default.when('isElementLookup', {
    is: true,
    then: joi_1.default.number().required(),
    otherwise: joi_1.default.any().strip(),
});
exports.lookupSchemas = {
    isDataLookup,
    dataLookupId,
    isElementLookup,
    elementLookupId,
};
exports.conditionallyShowSchemas = {
    conditionallyShow,
    requiresAllConditionallyShowPredicates,
    conditionallyShowPredicates: exports.conditionallyShowPredicates,
};
exports.storageType = joi_1.default.string()
    .custom((value, helpers) => {
    // Need to keep this here so that we still allow old forms to
    // be saved without throwing validation errors
    if (value === 'legacy') {
        return 'private';
    }
    if (value === 'private' || value === 'public') {
        return value;
    }
    return helpers.error('string.storageType');
})
    .messages({
    'string.storageType': '{{#label}} must be one of [public, private]',
});
const regexPattern = joi_1.default.string().custom((value) => {
    if (!value)
        return;
    try {
        new RegExp(value);
        return value;
    }
    catch (err) {
        throw new Error('it was an invalid regex pattern');
    }
});
const regexFlags = joi_1.default.when('regexPattern', {
    is: joi_1.default.string().required(),
    then: joi_1.default.string().regex(/^[dgimsuy]+$/),
    otherwise: joi_1.default.any().strip(),
});
const regexMessage = joi_1.default.string().when('regexPattern', {
    is: joi_1.default.string().required(),
    then: joi_1.default.required(),
    otherwise: joi_1.default.any().strip(),
});
exports.regexSchemas = {
    regexPattern,
    regexFlags,
    regexMessage,
};
exports.canToggleAll = joi_1.default.boolean().default(false);
exports.customCssClasses = joi_1.default.array().items(
//regex from here https://stackoverflow.com/a/449000
joi_1.default.string().regex(/^-?[_a-z]+[_a-z0-9-]*$/i));
//# sourceMappingURL=property-schemas.js.map