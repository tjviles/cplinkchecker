"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateElementNamesAcrossNestedElements = exports.getRootFormElements = exports.validateJoiSchema = void 0;
function validateJoiSchema(data, schema, options) {
    const result = schema.validate(data, options);
    if (result.error) {
        throw result.error;
    }
    return result.value;
}
exports.validateJoiSchema = validateJoiSchema;
const getRootFormElements = (elements) => {
    const rootFormElements = [];
    for (const element of elements) {
        if (element.type === 'page' || element.type === 'section') {
            rootFormElements.push(...(0, exports.getRootFormElements)(element.elements));
        }
        else {
            rootFormElements.push(element);
        }
    }
    return rootFormElements;
};
exports.getRootFormElements = getRootFormElements;
function checkElementNameUniqueness(elementNames, name) {
    // check if name already exists
    const existingName = elementNames.find((e) => e === name);
    if (existingName) {
        throw new Error(`Element name is not unique: ${name}`);
    }
}
function validateElementNamesAcrossNestedElements(elements) {
    const elementNames = [];
    for (const element of elements) {
        if (element.type === 'page' || element.type === 'section') {
            const childNames = validateElementNamesAcrossNestedElements(element.elements);
            for (const name of childNames) {
                checkElementNameUniqueness(elementNames, name);
                elementNames.push(name);
            }
        }
        else {
            checkElementNameUniqueness(elementNames, element.name);
            elementNames.push(element.name);
        }
    }
    return elementNames;
}
exports.validateElementNamesAcrossNestedElements = validateElementNamesAcrossNestedElements;
//# sourceMappingURL=common.js.map